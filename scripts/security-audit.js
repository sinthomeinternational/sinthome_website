#!/usr/bin/env node\n/**\n * Security Audit Script for Sinthome Website\n * Performs comprehensive security checks on the built application\n */\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { glob } from 'glob';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst projectRoot = path.resolve(__dirname, '..');\nconst distDir = path.join(projectRoot, 'dist');\n\nclass SecurityAuditor {\n  constructor() {\n    this.issues = [];\n    this.warnings = [];\n    this.passed = [];\n  }\n\n  addIssue(severity, category, message, file = null) {\n    const issue = { severity, category, message, file, timestamp: new Date().toISOString() };\n    \n    if (severity === 'ERROR') {\n      this.issues.push(issue);\n    } else {\n      this.warnings.push(issue);\n    }\n    \n    console.log(`[${severity}] ${category}: ${message}${file ? ` (${file})` : ''}`);\n  }\n\n  addPass(category, message) {\n    this.passed.push({ category, message, timestamp: new Date().toISOString() });\n    console.log(`[✅] ${category}: ${message}`);\n  }\n\n  async auditBuildOutput() {\n    console.log('🔍 Auditing build output...');\n    \n    try {\n      await fs.access(distDir);\n    } catch {\n      this.addIssue('ERROR', 'Build', 'Dist directory not found. Run build first.');\n      return;\n    }\n\n    const files = await glob('**/*', { cwd: distDir, nodir: true });\n    \n    for (const file of files) {\n      const filePath = path.join(distDir, file);\n      const content = await fs.readFile(filePath, 'utf-8').catch(() => null);\n      \n      if (!content) continue;\n      \n      // Check for exposed secrets\n      this.checkForSecrets(content, file);\n      \n      // Check for unsafe inline scripts\n      if (file.endsWith('.html')) {\n        this.checkHTMLSecurity(content, file);\n      }\n      \n      // Check JavaScript files\n      if (file.endsWith('.js') || file.endsWith('.mjs')) {\n        this.checkJavaScriptSecurity(content, file);\n      }\n    }\n    \n    this.addPass('Build Audit', `Scanned ${files.length} files`);\n  }\n\n  checkForSecrets(content, file) {\n    const secretPatterns = [\n      { name: 'API Key', pattern: /(?:api[_-]?key|apikey)\\s*[=:]\\s*['\"][a-zA-Z0-9]{20,}['\"]/gi },\n      { name: 'Secret Key', pattern: /(?:secret[_-]?key|secretkey)\\s*[=:]\\s*['\"][a-zA-Z0-9]{20,}['\"]/gi },\n      { name: 'Password', pattern: /(?:password|passwd|pwd)\\s*[=:]\\s*['\"][^'\"]{8,}['\"]/gi },\n      { name: 'Token', pattern: /(?:token|access[_-]?token)\\s*[=:]\\s*['\"][a-zA-Z0-9]{20,}['\"]/gi },\n      { name: 'Private Key', pattern: /-----BEGIN\\s+(?:RSA\\s+)?PRIVATE\\s+KEY-----/gi },\n      { name: 'Database URL', pattern: /(?:database[_-]?url|db[_-]?url)\\s*[=:]\\s*['\"][^'\"]+['\"]/gi }\n    ];\n\n    for (const { name, pattern } of secretPatterns) {\n      if (pattern.test(content)) {\n        this.addIssue('ERROR', 'Secrets', `Potential ${name} found in build output`, file);\n      }\n    }\n  }\n\n  checkHTMLSecurity(content, file) {\n    // Check for inline event handlers\n    const inlineEventPattern = /on\\w+\\s*=\\s*[\"'][^\"']*[\"']/gi;\n    if (inlineEventPattern.test(content)) {\n      this.addIssue('WARNING', 'XSS', 'Inline event handlers detected', file);\n    }\n\n    // Check for javascript: URLs\n    const javascriptUrlPattern = /href\\s*=\\s*[\"']javascript:/gi;\n    if (javascriptUrlPattern.test(content)) {\n      this.addIssue('ERROR', 'XSS', 'JavaScript URLs detected', file);\n    }\n\n    // Check for missing security headers meta tags\n    if (!content.includes('Content-Security-Policy')) {\n      this.addIssue('WARNING', 'CSP', 'No CSP meta tag found (should be set via headers)', file);\n    }\n\n    // Check for external script sources\n    const externalScriptPattern = /<script[^>]*src\\s*=\\s*[\"']https?:\\/\\/(?!docs\\.google\\.com)[^\"']*[\"'][^>]*>/gi;\n    const matches = content.match(externalScriptPattern);\n    if (matches) {\n      for (const match of matches) {\n        this.addIssue('WARNING', 'External Scripts', `External script detected: ${match}`, file);\n      }\n    }\n\n    this.addPass('HTML Security', `Scanned ${file}`);\n  }\n\n  checkJavaScriptSecurity(content, file) {\n    // Check for eval usage\n    if (/\\beval\\s*\\(/.test(content)) {\n      this.addIssue('ERROR', 'Code Injection', 'eval() usage detected', file);\n    }\n\n    // Check for Function constructor\n    if (/new\\s+Function\\s*\\(/.test(content)) {\n      this.addIssue('ERROR', 'Code Injection', 'Function constructor usage detected', file);\n    }\n\n    // Check for innerHTML with user data\n    if (/\\.innerHTML\\s*=/.test(content)) {\n      this.addIssue('WARNING', 'XSS', 'innerHTML assignment detected - ensure input is sanitized', file);\n    }\n\n    // Check for document.write\n    if (/document\\.write\\s*\\(/.test(content)) {\n      this.addIssue('WARNING', 'XSS', 'document.write usage detected', file);\n    }\n\n    this.addPass('JavaScript Security', `Scanned ${file}`);\n  }\n\n  async auditDependencies() {\n    console.log('📦 Auditing dependencies...');\n    \n    try {\n      const packageJson = JSON.parse(\n        await fs.readFile(path.join(projectRoot, 'package.json'), 'utf-8')\n      );\n      \n      const dependencies = {\n        ...packageJson.dependencies,\n        ...packageJson.devDependencies\n      };\n      \n      // Check for known vulnerable packages (simplified check)\n      const vulnerablePatterns = [\n        { name: 'lodash', version: '<4.17.19', issue: 'Prototype pollution vulnerability' },\n        { name: 'axios', version: '<0.21.1', issue: 'SSRF vulnerability' },\n        { name: 'node-sass', version: '*', issue: 'Deprecated package with security issues' }\n      ];\n      \n      for (const [pkg, version] of Object.entries(dependencies)) {\n        const vulnerable = vulnerablePatterns.find(v => pkg.includes(v.name));\n        if (vulnerable) {\n          this.addIssue('WARNING', 'Dependencies', \n            `${pkg}@${version} may be vulnerable: ${vulnerable.issue}`);\n        }\n      }\n      \n      this.addPass('Dependencies', `Checked ${Object.keys(dependencies).length} dependencies`);\n      \n    } catch (error) {\n      this.addIssue('ERROR', 'Dependencies', `Failed to read package.json: ${error.message}`);\n    }\n  }\n\n  async auditConfiguration() {\n    console.log('⚙️ Auditing configuration...');\n    \n    // Check for .env files in dist\n    const envFiles = await glob('.env*', { cwd: distDir }).catch(() => []);\n    if (envFiles.length > 0) {\n      this.addIssue('ERROR', 'Configuration', 'Environment files found in build output');\n    }\n    \n    // Check gitignore\n    try {\n      const gitignore = await fs.readFile(path.join(projectRoot, '.gitignore'), 'utf-8');\n      const requiredIgnores = ['.env', 'dist/', 'node_modules/'];\n      \n      for (const ignore of requiredIgnores) {\n        if (!gitignore.includes(ignore)) {\n          this.addIssue('WARNING', 'Configuration', `${ignore} not in .gitignore`);\n        }\n      }\n      \n      this.addPass('Configuration', 'Gitignore properly configured');\n    } catch {\n      this.addIssue('WARNING', 'Configuration', '.gitignore file not found');\n    }\n  }\n\n  generateReport() {\n    console.log('\\n📊 Security Audit Report');\n    console.log('=' .repeat(50));\n    \n    console.log(`\\n✅ Passed Checks: ${this.passed.length}`);\n    console.log(`⚠️  Warnings: ${this.warnings.length}`);\n    console.log(`❌ Critical Issues: ${this.issues.length}`);\n    \n    if (this.issues.length > 0) {\n      console.log('\\n🚨 Critical Issues:');\n      this.issues.forEach((issue, i) => {\n        console.log(`${i + 1}. [${issue.category}] ${issue.message}`);\n        if (issue.file) console.log(`   File: ${issue.file}`);\n      });\n    }\n    \n    if (this.warnings.length > 0) {\n      console.log('\\n⚠️  Warnings:');\n      this.warnings.forEach((warning, i) => {\n        console.log(`${i + 1}. [${warning.category}] ${warning.message}`);\n        if (warning.file) console.log(`   File: ${warning.file}`);\n      });\n    }\n    \n    // Save detailed report\n    const report = {\n      timestamp: new Date().toISOString(),\n      summary: {\n        passed: this.passed.length,\n        warnings: this.warnings.length,\n        issues: this.issues.length\n      },\n      passed: this.passed,\n      warnings: this.warnings,\n      issues: this.issues\n    };\n    \n    const reportPath = path.join(projectRoot, 'security-audit-report.json');\n    fs.writeFile(reportPath, JSON.stringify(report, null, 2))\n      .then(() => console.log(`\\n📄 Detailed report saved to: ${reportPath}`))\n      .catch(err => console.error('Failed to save report:', err));\n    \n    return this.issues.length === 0;\n  }\n\n  async run() {\n    console.log('🛡️  Starting Security Audit for Sinthome Website');\n    console.log('=' .repeat(50));\n    \n    await this.auditBuildOutput();\n    await this.auditDependencies();\n    await this.auditConfiguration();\n    \n    const passed = this.generateReport();\n    \n    if (passed) {\n      console.log('\\n🎉 Security audit passed!');\n      process.exit(0);\n    } else {\n      console.log('\\n❌ Security audit failed. Please address critical issues.');\n      process.exit(1);\n    }\n  }\n}\n\n// Run audit if called directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const auditor = new SecurityAuditor();\n  auditor.run().catch(error => {\n    console.error('Audit failed:', error);\n    process.exit(1);\n  });\n}\n\nexport default SecurityAuditor;"